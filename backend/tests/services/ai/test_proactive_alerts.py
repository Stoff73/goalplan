"""
Tests for Proactive Alerts Service - AI-Powered Financial Alert Detection

This module tests the ProactiveAlertsService including:
- Change detection (spending, income, balance, goals, investments)
- Opportunity detection (allowances, tax, emergency fund, portfolio)
- Alert generation for all alert types
- Urgency classification
- Batch processing
- Deduplication logic
- LLM integration (mocked)

All tests use mocked data and mocked LLM API calls.
"""

import pytest
from decimal import Decimal
from datetime import datetime, date, timedelta
from uuid import uuid4
from unittest.mock import AsyncMock, MagicMock, patch

from sqlalchemy.ext.asyncio import AsyncSession

from models.user import User, UserStatus, CountryPreference
from models.tax_status import UserTaxStatus, UKDomicileStatus
from models.income import UserIncome, IncomeType, IncomeFrequency
from models.savings_account import SavingsAccount, ISAContribution, TFSAContribution
from models.investment import InvestmentAccount, AccountType
from models.retirement import UKPension, PensionType
from models.goal import FinancialGoal, GoalType, GoalStatus, GoalPriority
from models.recommendation import Recommendation, RecommendationType, RecommendationPriority
from services.ai.proactive_alerts_service import ProactiveAlertsService, AlertType, AlertUrgency


@pytest.fixture
async def test_user(db_session: AsyncSession) -> User:
    """Create a test user."""
    user = User(
        id=uuid4(),
        email="test@example.com",
        first_name="Test",
        last_name="User",
        country_preference=CountryPreference.UK,
        status=UserStatus.ACTIVE,
        email_verified=True,
        terms_accepted_at=datetime.utcnow(),
        date_of_birth=date(1985, 5, 15)  # Age 39/40
    )
    db_session.add(user)
    await db_session.commit()
    await db_session.refresh(user)
    return user


@pytest.fixture
async def test_tax_status(db_session: AsyncSession, test_user: User) -> UserTaxStatus:
    """Create test tax status."""
    tax_status = UserTaxStatus(
        user_id=test_user.id,
        uk_tax_resident=True,
        sa_tax_resident=False,
        uk_domicile=UKDomicileStatus.UK_DOMICILE,
        effective_from=date(2024, 4, 6),
        effective_to=None
    )
    db_session.add(tax_status)
    await db_session.commit()
    await db_session.refresh(tax_status)
    return tax_status


@pytest.fixture
async def test_income(db_session: AsyncSession, test_user: User) -> UserIncome:
    """Create test income."""
    income = UserIncome(
        user_id=test_user.id,
        income_type=IncomeType.EMPLOYMENT,
        source_name="Test Company Ltd",
        annual_amount=Decimal('45000.00'),
        currency='GBP',
        income_frequency=IncomeFrequency.MONTHLY,
        country='UK'
    )
    db_session.add(income)
    await db_session.commit()
    await db_session.refresh(income)
    return income


@pytest.fixture
async def test_savings_account(db_session: AsyncSession, test_user: User) -> SavingsAccount:
    """Create test savings account."""
    account = SavingsAccount(
        user_id=test_user.id,
        account_name="Test ISA",
        account_type="ISA",
        provider="Test Bank",
        account_number_encrypted="12345678",
        current_balance=Decimal('5000.00'),
        currency='GBP'
    )
    db_session.add(account)
    await db_session.commit()
    await db_session.refresh(account)
    return account


@pytest.fixture
async def test_goal(db_session: AsyncSession, test_user: User) -> FinancialGoal:
    """Create test financial goal."""
    goal = FinancialGoal(
        user_id=test_user.id,
        goal_name="Emergency Fund",
        goal_type=GoalType.EMERGENCY_FUND,
        target_amount=Decimal('10000.00'),
        current_amount=Decimal('2500.00'),
        progress_percentage=Decimal('25.00'),
        currency='GBP',
        target_date=date.today() + timedelta(days=365),
        start_date=date.today() - timedelta(days=90),
        priority=GoalPriority.HIGH,
        status=GoalStatus.IN_PROGRESS
    )
    db_session.add(goal)
    await db_session.commit()
    await db_session.refresh(goal)
    return goal


@pytest.fixture
def mock_llm_response():
    """Mock LLM response."""
    return {
        "advice": "This is a test alert message generated by the AI. It provides actionable advice based on your financial situation.",
        "confidence_score": 0.85,
        "requires_human_review": False,
        "metadata": {
            "model": "gpt-4-turbo-preview",
            "tokens_used": 150,
            "prompt_tokens": 100,
            "completion_tokens": 50,
            "temperature": 0.7,
            "advice_type": "general",
            "timestamp": datetime.utcnow().isoformat()
        }
    }


@pytest.mark.asyncio
class TestProactiveAlertsService:
    """Tests for ProactiveAlertsService."""

    async def test_service_initialization(self, db_session: AsyncSession):
        """Test service initializes correctly."""
        service = ProactiveAlertsService(db_session)

        assert service.db == db_session
        assert service.llm_service is not None
        assert service.dashboard_service is not None

    async def test_analyze_financial_changes(
        self,
        db_session: AsyncSession,
        test_user: User,
        test_tax_status: UserTaxStatus,
        test_income: UserIncome,
        test_goal: FinancialGoal
    ):
        """Test financial change analysis."""
        service = ProactiveAlertsService(db_session)

        # Analyze changes
        result = await service.analyze_financial_changes(test_user.id, lookback_days=30)

        # Should return changes and opportunities
        assert "changes" in result
        assert "opportunities" in result
        assert isinstance(result["changes"], list)
        assert isinstance(result["opportunities"], list)

    async def test_detect_goal_changes_milestone(
        self,
        db_session: AsyncSession,
        test_user: User,
        test_goal: FinancialGoal
    ):
        """Test goal milestone detection."""
        # Update goal to 25% progress (milestone)
        test_goal.current_amount = Decimal('2500.00')
        test_goal.progress_percentage = Decimal('25.00')
        await db_session.commit()

        service = ProactiveAlertsService(db_session)
        changes = await service._detect_goal_changes(test_user.id)

        # Should detect milestone
        milestone_changes = [c for c in changes if c["type"] == "goal_milestone"]
        assert len(milestone_changes) > 0
        assert milestone_changes[0]["progress_pct"] == 25.0

    async def test_detect_goal_changes_achieved(
        self,
        db_session: AsyncSession,
        test_user: User,
        test_goal: FinancialGoal
    ):
        """Test goal achievement detection."""
        # Update goal to 100% progress
        test_goal.current_amount = Decimal('10000.00')
        test_goal.progress_percentage = Decimal('100.00')
        await db_session.commit()

        service = ProactiveAlertsService(db_session)
        changes = await service._detect_goal_changes(test_user.id)

        # Should detect achievement
        achieved_changes = [c for c in changes if c["type"] == "goal_achieved"]
        assert len(achieved_changes) > 0

    async def test_detect_goal_changes_falling_behind(
        self,
        db_session: AsyncSession,
        test_user: User
    ):
        """Test goal falling behind detection."""
        # Create a goal that's falling behind
        goal = FinancialGoal(
            user_id=test_user.id,
            goal_name="House Deposit",
            goal_type=GoalType.HOUSE_PURCHASE,
            target_amount=Decimal('50000.00'),
            current_amount=Decimal('5000.00'),  # Only 10% after 6 months
            progress_percentage=Decimal('10.00'),
            currency='GBP',
            target_date=date.today() + timedelta(days=180),  # 6 months from now
            start_date=date.today() - timedelta(days=180),  # Started 6 months ago
            priority=GoalPriority.HIGH,
            status=GoalStatus.IN_PROGRESS
        )
        db_session.add(goal)
        await db_session.commit()

        service = ProactiveAlertsService(db_session)
        changes = await service._detect_goal_changes(test_user.id)

        # Should detect falling behind (expected 50% progress, only at 10%)
        falling_behind = [c for c in changes if c["type"] == "goal_falling_behind"]
        assert len(falling_behind) > 0

    async def test_identify_isa_allowance_opportunity(
        self,
        db_session: AsyncSession,
        test_user: User,
        test_tax_status: UserTaxStatus
    ):
        """Test ISA allowance opportunity detection."""
        # Add small ISA contribution (leaving lots of allowance)
        contribution = ISAContribution(
            user_id=test_user.id,
            contribution_amount=Decimal('2000.00'),
            contribution_date=date.today(),
            tax_year='2024/25'
        )
        db_session.add(contribution)
        await db_session.commit()

        service = ProactiveAlertsService(db_session)
        opportunities = await service._identify_allowance_opportunities(test_user.id)

        # Should identify ISA allowance opportunity
        isa_opps = [o for o in opportunities if o["type"] == "isa_allowance"]

        # Only alert if within 90 days of deadline
        if isa_opps:
            assert isa_opps[0]["remaining"] > 10000  # >£10k remaining
            assert isa_opps[0]["allowance_type"] == "ISA"

    async def test_identify_tax_threshold_opportunity(
        self,
        db_session: AsyncSession,
        test_user: User,
        test_income: UserIncome
    ):
        """Test tax threshold proximity detection."""
        # Set income close to higher rate threshold
        test_income.annual_amount = Decimal('48000.00')  # £2,270 below threshold
        await db_session.commit()

        service = ProactiveAlertsService(db_session)
        opportunities = await service._identify_tax_opportunities(test_user.id)

        # Should identify tax threshold opportunity
        tax_opps = [o for o in opportunities if o["type"] == "tax_threshold"]
        assert len(tax_opps) > 0
        assert tax_opps[0]["distance"] < 5000  # Within £5k of threshold

    async def test_identify_emergency_fund_opportunity(
        self,
        db_session: AsyncSession,
        test_user: User,
        test_income: UserIncome,
        test_savings_account: SavingsAccount
    ):
        """Test emergency fund adequacy check."""
        # Set low emergency fund balance
        test_savings_account.current_balance = Decimal('3000.00')
        test_savings_account.account_type = "SAVINGS_ACCOUNT"
        await db_session.commit()

        service = ProactiveAlertsService(db_session)
        opportunities = await service._identify_emergency_fund_opportunities(test_user.id)

        # Should identify emergency fund shortfall
        # Recommended: 6 months * (£45k / 12) * 80% = £18k
        # Current: £3k
        emergency_opps = [o for o in opportunities if o["type"] == "emergency_fund"]
        assert len(emergency_opps) > 0
        assert emergency_opps[0]["current"] < emergency_opps[0]["recommended"]

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_allowance_alert(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test ISA allowance alert generation."""
        # Mock LLM response
        mock_generate.return_value = mock_llm_response

        service = ProactiveAlertsService(db_session)

        allowance_data = {
            "type": "ISA",
            "used": 5000.00,
            "remaining": 15000.00,
            "annual_limit": 20000.00,
            "deadline": date(2025, 4, 5),
            "currency": "GBP"
        }

        alert = await service.generate_allowance_alert(test_user.id, allowance_data)

        # Verify alert created
        assert alert is not None
        assert alert.user_id == test_user.id
        assert alert.recommendation_type == RecommendationType.ISA
        assert "ISA" in alert.title
        assert alert.description == mock_llm_response["advice"]

        # Verify urgency based on deadline
        days_to_deadline = (allowance_data["deadline"] - date.today()).days
        if days_to_deadline < 30:
            assert alert.priority == RecommendationPriority.HIGH
        elif days_to_deadline < 60:
            assert alert.priority == RecommendationPriority.MEDIUM
        else:
            assert alert.priority == RecommendationPriority.LOW

        # Verify LLM was called
        mock_generate.assert_called_once()

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_goal_progress_alert_milestone(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        test_goal: FinancialGoal,
        mock_llm_response: dict
    ):
        """Test goal milestone alert generation."""
        # Mock LLM response
        mock_generate.return_value = mock_llm_response

        # Set goal to milestone (25%)
        test_goal.current_amount = Decimal('2500.00')
        test_goal.progress_percentage = Decimal('25.00')
        await db_session.commit()

        service = ProactiveAlertsService(db_session)
        alert = await service.generate_goal_progress_alert(test_user.id, test_goal)

        # Verify alert created
        assert alert is not None
        assert alert.user_id == test_user.id
        assert test_goal.goal_name in alert.title
        assert alert.priority == RecommendationPriority.LOW  # Milestone is low urgency

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_goal_progress_alert_falling_behind(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test goal falling behind alert generation."""
        # Mock LLM response
        mock_generate.return_value = mock_llm_response

        # Create goal that's falling behind
        goal = FinancialGoal(
            user_id=test_user.id,
            goal_name="House Deposit",
            goal_type=GoalType.HOUSE_PURCHASE,
            target_amount=Decimal('50000.00'),
            current_amount=Decimal('5000.00'),
            progress_percentage=Decimal('10.00'),
            currency='GBP',
            target_date=date.today() + timedelta(days=180),
            start_date=date.today() - timedelta(days=180),
            priority=GoalPriority.HIGH,
            status=GoalStatus.IN_PROGRESS
        )
        db_session.add(goal)
        await db_session.commit()

        service = ProactiveAlertsService(db_session)
        alert = await service.generate_goal_progress_alert(test_user.id, goal)

        # Verify alert created
        assert alert is not None
        assert alert.priority == RecommendationPriority.MEDIUM  # Falling behind is medium urgency
        assert len(alert.action_items) > 0

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_tax_threshold_alert(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test tax threshold alert generation."""
        # Mock LLM response
        mock_generate.return_value = mock_llm_response

        service = ProactiveAlertsService(db_session)

        income_data = {
            "income": 48000.00,
            "threshold": 50270.00,
            "distance": 2270.00
        }

        alert = await service.generate_tax_threshold_alert(test_user.id, income_data)

        # Verify alert created
        assert alert is not None
        assert alert.user_id == test_user.id
        assert alert.recommendation_type == RecommendationType.TAX_EFFICIENCY
        assert alert.priority == RecommendationPriority.MEDIUM
        assert alert.potential_savings is not None
        assert alert.potential_savings > 0  # Should calculate tax saving

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_spending_alert(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test spending pattern alert generation."""
        # Mock LLM response
        mock_generate.return_value = mock_llm_response

        service = ProactiveAlertsService(db_session)

        spending_data = {
            "current": 3200.00,
            "average": 2500.00,
            "increase_pct": 28.0
        }

        alert = await service.generate_spending_alert(test_user.id, spending_data)

        # Verify alert created
        assert alert is not None
        assert alert.user_id == test_user.id
        assert alert.priority == RecommendationPriority.MEDIUM
        assert len(alert.action_items) > 0

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_investment_alert_rebalance(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test portfolio rebalancing alert generation."""
        # Mock LLM response
        mock_generate.return_value = mock_llm_response

        service = ProactiveAlertsService(db_session)

        portfolio_data = {
            "alert_type": "rebalance",
            "asset_class": "UK Equities",
            "current_pct": 65.0,
            "target_pct": 50.0
        }

        alert = await service.generate_investment_alert(test_user.id, portfolio_data)

        # Verify alert created
        assert alert is not None
        assert alert.recommendation_type == RecommendationType.INVESTMENT_DIVERSIFICATION
        assert alert.priority == RecommendationPriority.MEDIUM

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_investment_alert_performance(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test investment performance alert generation."""
        # Mock LLM response
        mock_generate.return_value = mock_llm_response

        service = ProactiveAlertsService(db_session)

        portfolio_data = {
            "alert_type": "performance",
            "performance_pct": 12.5,
            "period": "month"
        }

        alert = await service.generate_investment_alert(test_user.id, portfolio_data)

        # Verify alert created
        assert alert is not None
        assert alert.priority == RecommendationPriority.LOW  # Performance alerts are informational

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_retirement_alert(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test retirement contribution alert generation."""
        # Mock LLM response
        mock_generate.return_value = mock_llm_response

        service = ProactiveAlertsService(db_session)

        pension_data = {
            "additional_contribution": 100.00,
            "tax_saving_annual": 40.00,  # 40% tax relief
            "years_to_retirement": 25
        }

        alert = await service.generate_retirement_alert(test_user.id, pension_data)

        # Verify alert created
        assert alert is not None
        assert alert.recommendation_type == RecommendationType.PENSION
        assert alert.priority == RecommendationPriority.MEDIUM
        assert alert.potential_savings is not None
        assert alert.potential_savings == Decimal('1000.00')  # £40 * 25 years

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    @patch('services.ai.proactive_alerts_service.LLMService.create_financial_context')
    async def test_generate_alerts(
        self,
        mock_context: AsyncMock,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        test_goal: FinancialGoal,
        mock_llm_response: dict
    ):
        """Test alert generation from changes and opportunities."""
        # Mock LLM responses
        mock_context.return_value = {"demographics": {"age": 40}, "financial_position": {}}
        mock_generate.return_value = mock_llm_response

        service = ProactiveAlertsService(db_session)

        # Create test changes and opportunities
        changes = [
            {
                "type": "goal_milestone",
                "goal_id": str(test_goal.id),
                "goal_name": test_goal.goal_name,
                "progress_pct": 25.0,
                "severity": "low"
            }
        ]

        opportunities = [
            {
                "type": "isa_allowance",
                "allowance_type": "ISA",
                "used": 5000.00,
                "remaining": 15000.00,
                "annual_limit": 20000.00,
                "deadline": date(2025, 4, 5),
                "currency": "GBP",
                "severity": "medium"
            }
        ]

        # Generate alerts
        alerts = await service.generate_alerts(test_user.id, changes, opportunities)

        # Verify alerts generated
        assert len(alerts) > 0
        assert all(isinstance(a, Recommendation) for a in alerts)
        assert all(a.user_id == test_user.id for a in alerts)

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    @patch('services.ai.proactive_alerts_service.LLMService.create_financial_context')
    async def test_deduplication(
        self,
        mock_context: AsyncMock,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test alert deduplication within 7-day window."""
        # Mock LLM responses
        mock_context.return_value = {"demographics": {"age": 40}, "financial_position": {}}
        mock_generate.return_value = mock_llm_response

        # Create existing alert (recent)
        existing_alert = Recommendation(
            user_id=test_user.id,
            recommendation_type=RecommendationType.ISA,
            priority=RecommendationPriority.MEDIUM,
            title="Use ISA allowance",
            description="Test alert",
            created_date=datetime.utcnow() - timedelta(days=3)  # 3 days ago
        )
        db_session.add(existing_alert)
        await db_session.commit()

        service = ProactiveAlertsService(db_session)

        # Try to create duplicate ISA alert
        opportunities = [
            {
                "type": "isa_allowance",
                "allowance_type": "ISA",
                "used": 5000.00,
                "remaining": 15000.00,
                "annual_limit": 20000.00,
                "deadline": date(2025, 4, 5),
                "currency": "GBP",
                "severity": "medium"
            }
        ]

        alerts = await service.generate_alerts(test_user.id, [], opportunities)

        # Should not create duplicate (within 7-day window)
        isa_alerts = [a for a in alerts if a.recommendation_type == RecommendationType.ISA]
        assert len(isa_alerts) == 0  # Deduplication should prevent creation

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    @patch('services.ai.proactive_alerts_service.LLMService.create_financial_context')
    @patch('services.ai.proactive_alerts_service.DashboardAggregationService.get_dashboard_summary')
    async def test_batch_generate_monthly_insights(
        self,
        mock_dashboard: AsyncMock,
        mock_context: AsyncMock,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        mock_llm_response: dict
    ):
        """Test batch monthly insights generation."""
        # Mock responses
        mock_dashboard.return_value = {"net_worth": {"total_gbp": 50000.00}}
        mock_context.return_value = {"demographics": {"age": 40}, "financial_position": {}}
        mock_generate.return_value = mock_llm_response

        service = ProactiveAlertsService(db_session)

        # Generate monthly insights for all users
        result = await service.batch_generate_monthly_insights()

        # Verify summary
        assert "total_users" in result
        assert "insights_generated" in result
        assert "errors" in result
        assert result["total_users"] > 0

    @patch('services.ai.proactive_alerts_service.LLMService.create_financial_context')
    async def test_schedule_daily_analysis(
        self,
        mock_context: AsyncMock,
        db_session: AsyncSession,
        test_user: User,
        test_tax_status: UserTaxStatus,
        test_income: UserIncome
    ):
        """Test daily analysis batch job."""
        # Mock context
        mock_context.return_value = {"demographics": {"age": 40}, "financial_position": {}}

        service = ProactiveAlertsService(db_session)

        # Run daily analysis
        result = await service.schedule_daily_analysis()

        # Verify summary
        assert "users_analyzed" in result
        assert "alerts_generated" in result
        assert "errors" in result
        assert result["users_analyzed"] > 0

    async def test_max_alerts_per_user_limit(
        self,
        db_session: AsyncSession,
        test_user: User,
        test_goal: FinancialGoal
    ):
        """Test that alert generation respects max alerts per user limit."""
        service = ProactiveAlertsService(db_session)

        # Create many changes (more than MAX_ALERTS_PER_USER)
        changes = []
        for i in range(15):
            changes.append({
                "type": "goal_milestone",
                "goal_id": str(test_goal.id),
                "goal_name": f"Goal {i}",
                "progress_pct": 25.0,
                "severity": "low"
            })

        # Mock LLM to avoid actual API calls
        with patch('services.ai.proactive_alerts_service.LLMService.create_financial_context') as mock_context:
            with patch('services.ai.proactive_alerts_service.LLMService.generate_completion') as mock_generate:
                mock_context.return_value = {"demographics": {}, "financial_position": {}}
                mock_generate.return_value = {
                    "advice": "Test",
                    "confidence_score": 0.8,
                    "requires_human_review": False,
                    "metadata": {}
                }

                alerts = await service.generate_alerts(test_user.id, changes, [])

        # Should be limited to MAX_ALERTS_PER_USER
        assert len(alerts) <= service.MAX_ALERTS_PER_USER

    async def test_uk_tax_year_dates(self, db_session: AsyncSession):
        """Test UK tax year date calculations."""
        service = ProactiveAlertsService(db_session)

        tax_year_start = service._get_uk_tax_year_start()
        tax_year_end = service._get_uk_tax_year_end()

        # Verify April 6 to April 5
        assert tax_year_start.month == 4
        assert tax_year_start.day == 6
        assert tax_year_end.month == 4
        assert tax_year_end.day == 5

        # End should be after start
        assert tax_year_end > tax_year_start

    async def test_sa_tax_year_dates(self, db_session: AsyncSession):
        """Test SA tax year date calculations."""
        service = ProactiveAlertsService(db_session)

        tax_year_start = service._get_sa_tax_year_start()
        tax_year_end = service._get_sa_tax_year_end()

        # Verify March 1 to Feb 28/29
        assert tax_year_start.month == 3
        assert tax_year_start.day == 1
        assert tax_year_end.month == 2
        assert tax_year_end.day in [28, 29]

        # End should be after start
        assert tax_year_end > tax_year_start

    async def test_analyze_financial_changes_user_not_found(self, db_session: AsyncSession):
        """Test error handling when user doesn't exist."""
        service = ProactiveAlertsService(db_session)

        fake_user_id = uuid4()

        with pytest.raises(ValueError, match="User .* not found"):
            await service.analyze_financial_changes(fake_user_id)

    @patch('services.ai.proactive_alerts_service.LLMService.generate_completion')
    async def test_generate_allowance_alert_no_opportunity_far_deadline(
        self,
        mock_generate: AsyncMock,
        db_session: AsyncSession,
        test_user: User
    ):
        """Test that no alert is generated when deadline is far away."""
        service = ProactiveAlertsService(db_session)

        # Deadline is 6 months away
        allowance_data = {
            "type": "ISA",
            "used": 5000.00,
            "remaining": 15000.00,
            "annual_limit": 20000.00,
            "deadline": date.today() + timedelta(days=180),
            "currency": "GBP"
        }

        # Should still create alert but with lower urgency
        alert = await service.generate_allowance_alert(test_user.id, allowance_data)

        assert alert is not None
        assert alert.priority == RecommendationPriority.LOW

    async def test_currency_symbol_helper(self):
        """Test currency symbol helper function."""
        from services.ai.proactive_alerts_service import currency_symbol

        assert currency_symbol("GBP") == "£"
        assert currency_symbol("ZAR") == "R"
        assert currency_symbol("USD") == "$"
        assert currency_symbol("EUR") == "€"
        assert currency_symbol("UNKNOWN") == "UNKNOWN"
